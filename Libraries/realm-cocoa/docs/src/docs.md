---
layout: docs
tagline: ": iOS Guide"
---

<div class="col-md-8">
<div class="docs-wrapper">

## Getting Started

### Manual installation

1. Download the [latest release of Realm](http://static.realm.io/downloads/ios/latest) and extract the zip.
2. Drag Realm.framework from our release and into the Frameworks folder in your project in Xcode.
   Make sure **Copy items into destination group’s folder** is selected and press **Finish**.
3. Click on the project in the Xcode file explorer.
   Select your target and go to the **Build Phases** tab. Under **Link Binary with Libraries** press + and add **libc++.dylib**.

### Installation via CocoaPods

If you use [CocoaPods](http://cocoapods.org/)…

1. Add the following to your Podfile: `pod "Realm"`.
2. From the command line, run `pod install`.
3. Use the `.xcworkspace` file generated by CocoaPods to work on your project!

### API Reference

Please consult our online [API Reference](api/) for detailed class, method & property signatures. You can add our reference docs directly to Xcode (via [Docs for Xcode](http://documancer.com/xcode/)) or to [Dash](http://kapeli.com/dash), using the links in the upper-right corner of our online [API Reference](api/).

### Plugin

Our Xcode plugin makes it easy to generate new Realm models (and will soon come with a built-in data browser for .realm files).

- You can install the plugin manually by opening plugin/RealmPlugin.xcodeproj contained in the release zip and clicking build. You will need to quit and relaunch Xcode to see our plugin.
- If you use [Alcatraz](http://alcatraz.io/) you will soon find our plugin under “Realm”.

### Getting Help

- Sign up for our [community newsletter](http://eepurl.com/VEKCn) to get regular tips, learn about other use-cases and get alerted of blogposts & tutorials about Realm.
- **StackOverflow**: look for previous questions under the tag [#realm](https://stackoverflow.com/questions/tagged/realm) — or [open a new one](http://stackoverflow.com/questions/ask?tags=realm).
- **Twitter**: contact [@realm](http://twitter.com/realm) or use [#realm](https://twitter.com/search?q=%23realm&src=typd&f=realtime).
- **Email**: [help@realm.io](mailto:help@realm.io).

## Models

Realm data models are defined using traditional NSObject-style classes with @properties. Just subclass RLMObject to create your Realm data model objects. You can add your own methods and protocols to Realm data models like you would any other object.

Relationships and nested data structures are modeled simply by including properties of the target type or RLMArray's for typed lists of objects.

<div class="highlight-wrapper">

{% highlight swift %}
// Dog model
class Dog: RLMObject {
    var name = ""
    var owner = Person()
}

// Person model
class Person: RLMObject {
    name = ""
    birthdate = NSDate(timeIntervalSince1970: 1)
    dogs = RLMArray(objectClassName: Dog.className())
}
{% endhighlight%}

{% highlight objective-c %}
@class Person;

// Dog model
@interface Dog : RLMObject
@property NSString *name;
@property Person   *owner;
@end
RLM_ARRAY_TYPE(Dog) // define RLMArray<Dog>

// Person model
@interface Person : RLMObject
@property NSString      *name;
@property NSDate        *birthdate;
@property RLMArray<Dog> *dogs;
@end
RLM_ARRAY_TYPE(Person) // define RLMArray<Person>

// Implementations
@implementation Dog
@end

@implementation Person
@end
{% endhighlight %}

</div><!--/highlight-wrapper -->


See [RLMObject](api/Classes/RLMObject.html#) for more details.


## Writes

All writes must be done via a write transaction:

<div class="highlight-wrapper">

{% highlight swift %}
// Get the default Realm
let realm = RLMRealm.defaultRealm()

// Create a Person object
let author = Person()
author.name = "David Foster Wallace"

// Add to the Realm inside a transaction
realm.beginWriteTransaction()
realm.addObject(author)
realm.commitWriteTransaction()
{% endhighlight%}

{% highlight objective-c %}
// Get the default Realm
RLMRealm *realm = [RLMRealm defaultRealm];

// Create object
Person *author = [[Person alloc] init];
author.name    = @"David Foster Wallace";

// Add to Realm with transaction
[realm beginWriteTransaction];
[realm addObject:author];
[realm commitWriteTransaction];
{% endhighlight %}

</div><!--/highlight-wrapper -->


See [RLMRealm](api/Classes/RLMRealm.html#) and [RLMObject](api/Classes/RLMObject.html#) for more details.

## Queries

**_A note about using Realm Arrays (RLMArray)_**: All successful calls to retrieval and querying methods return the resulting collection of RLMObjects in an RLMArray. RLMArrays can be manipulated similarly to a standard NSArray; however, RLMArrays are typed, meaning they only hold RLMObjects of the same RLMObject subclass type. For more details see [RLMArray](api/Classes/RLMArray.html#).

### Retrieving Objects by Type

The most basic method for retrieving objects from a Realm is [`[RLMObject allObjects]`](api/Classes/RLMObject.html#//api/name/allObjects), which returns all RLMObject instances of the same subclass type from the default Realm.

<div class="highlight-wrapper">

{% highlight swift %}
// Query the default Realm
let dogs = Dog.allObjects()

// Query a specific Realm
let petsRealm = RLMRealm.realmWithPath("pets.realm")
let otherDogs = Dog.allObjectsInRealm(petsRealm)
{% endhighlight%}

{% highlight objective-c %}
// On the default Realm:
RLMArray *dogs = [Dog allObjects]; // retrieves all Dogs from the default Realm

// On a specific Realm
RLMRealm *petsRealm = [RLMRealm realmWithPath:@"pets.realm"]; // get a specific Realm
RLMArray *otherDogs = [Dog allObjectsInRealm:petsRealm]; // retrieve all Dogs from that Realm
{% endhighlight %}

</div><!--/highlight-wrapper -->


### Querying with Predicates

If you're familiar with [NSPredicate](https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSPredicate_Class/Reference/NSPredicate.html), then you already know how to query in Realm. RLMObjects, RLMRealm and RLMArray all provide methods that allow you to query for specific RLMObjects instances by simply passing in an NSPredicate instance, predicate string, or predicate format string just as you would with an NSObject instance.

For example, the following would extend our earlier example by calling `[RLMObject objectsWhere:]` to retrieve all dogs with the color tan and names beginning with 'B' from the default Realm:

<div class="highlight-wrapper">

{% highlight swift %}
// Query using a predicate string:
let tanDogs = Dog.objectsWhere("color = 'tan' AND name BEGINSWITH 'B'")

// Query using an NSPredicate object:
let predicate = NSPredicate(format: "color = %@ AND name BEGINSWITH %@", "tan", "B")
let tanDogs2 = Dog.objectsWithPredicate(predicate)
{% endhighlight%}

{% highlight objective-c %}
// Using a predicate string
RLMArray *tanDogs = [Dog objectsWhere:@"color = 'tan' AND name BEGINSWITH 'B'"];

// … Or using an NSPredicate object
NSPredicate *pred = [NSPredicate predicateWithFormat:@"color = %@ AND name BEGINSWITH %@",
                                                     @"tan", @"B"];
RLMArray *tanDogs2 = [Dog objectsWithPredicate:pred];
{% endhighlight %}
</div><!--/highlight-wrapper -->

For more, see [`[RLMObject objectsWhere:]`](api/Classes/RLMObject.html#//api/name/objectsWhere:).

### Ordering Results

In many cases it is desirable to be able to have a retrieval or query operation return an ordered result set. To enable this, RLMArray supports method that allow you to specify a property name to order the result set by.

For example, the following calls `[RLMObject objectsWhere:where:]` to sort the returned dogs from the example above alphabetically by name:

<div class="highlight-wrapper">

{% highlight swift %}
// Using a string (sort is ascending by default)
var sortedDogs = Dog.objectsWhere("color = 'tan' AND name BEGINSWITH 'B'").arraySortedByProperty("name", ascending: true)
{% endhighlight%}

{% highlight objective-c %}
// Using a string (sort is ascending by default)
RLMArray *sortedDogs = [[Dog objectsWhere:@"color = 'tan' AND name BEGINSWITH 'B'"]
                    arraySortedByProperty:@"name" ascending:YES];
{% endhighlight %}

</div><!--/highlight-wrapper -->


For more, see [`[RLMObject objectsWhere:]`](api/Classes/RLMObject.html#//api/name/objectsWhere:) and [`[RLMArray arraySortedByProperty:]`](api/Classes/RLMArray.html/#//api/name/arraySortedByProperty:).

### Chaining Queries

Another advantage of Realm's use of regular objects to store your application data is the ability to chain queries with very little transactional overhead, compared to traditional databases that require a separate trip to the database server for each successive query.

For example, if we wanted a result set for just the tan colored dogs, and the tan colored dogs whose names also started with 'B', you might chain two queries like this:

<div class="highlight-wrapper">

{% highlight swift %}
let tanDogs = Dog.objectsWhere("color = 'tan'")
let tanDogsWithBNames = tanDogs.objectsWhere("name BEGINSWITH 'B'")
{% endhighlight%}

{% highlight objective-c %}
RLMArray *tanDogs = [Dog objectsWhere:@"color = 'tan'"];
RLMArray *tanDogsWithBNames = [tanDogs objectsWhere:@"name BEGINSWITH 'B'"];
{% endhighlight %}

</div><!--/highlight-wrapper -->


## Realms

### The Default Realm

You may have noticed so far that we have always initialized access to our `realm` variable by calling `[RLMRealm defaultRealm]`. That method returns an RLMRealm object that maps to a file called “default.realm” under the Documents folder of your app. Write transactions will be automatically written to disk at that location for you, and likewise for reads.

### In-Memory Default Realm

The Default Realm is persisted to disk by default, but you can also use it purely in memory by calling the following line before any call to `[RLMRealm defaultRealm]`.

<div class="highlight-wrapper">

{% highlight swift %}
// You must call this method before accessing the default Realm
RLMRealm.useInMemoryDefaultRealm()
let realm = RLMRealm.defaultRealm()
{% endhighlight%}

{% highlight objective-c %}
[RLMRealm useInMemoryDefaultRealm]; 
RLMRealm *realm = [RLMRealm defaultRealm]; // Only call this line after!
{% endhighlight %}

</div><!--/highlight-wrapper -->


This option is only available on the default Realm.

If you use your default Realm in memory, it will not persist your RLMObjects, meaning data will not be saved across app launches. However, all other features of Realm will work as expected, including querying, relationships & thread-safety. This is a useful option if you need flexible data access without the overhead of disk persistence.

### Other Realms

It’s sometimes useful to have multiple realms, persisted at different locations, for example if you have different data groupings, different databases per feature, or you need to package some read-only files with your app, separate from the database your users will be editing. See [`[RLMRealm realmWithPath:]`](api/Classes/RLMRealm.html#//api/name/realmWithPath:) and [`[RLMRealm realmWithPath:readOnly:error:]`](api/Classes/RLMRealm.html#//api/name/realmWithPath:readOnly:error:) for more info.

### Using a Realm Across Threads

If you are trying to access the same realm file from different threads, you should call `[RLMRealm defaultRealm]`, `[RLMRealm realmWithPath:]` or `[RLMRealm realmWithPath:readOnly:error:]` to get a different Realm object for every thread of your app. As long as you specify the same path, all RLMRealm objects will map to the same file on disk.  
**Do _not_ share RLMRealm objects across threads**. It’s totally fine to have many RLMRealm objects, all mapping to the same file. You can even have multiple RLMRealm objects pointing to the same file living on the same thread.

## Relationships

Any two RLMObjects can be linked together. Assuming your Person model has already been defined ([see above](#models)) let’s create another model called Dog:

<div class="highlight-wrapper">

{% highlight swift %}
class Dog: RLMObject {
    var name = ""
}
{% endhighlight%}

{% highlight objective-c %} 
// Dog.h
@interface Dog : RLMObject
@property NSString *name;
@end
{% endhighlight %}

</div><!--/highlight-wrapper -->

 
### Many-to-One
 
Simply declare a property with the type of one of your RLMObject subclasses:

<div class="highlight-wrapper">

{% highlight swift %}
class Dog: RLMObject {
    ... // other property declarations
    var owner = Person()	
}
{% endhighlight%}

{% highlight objective-c %} 
// Person.h
@interface Dog : RLMObject
... // other property declarations
@property Person   *owner;
@end
{% endhighlight %}

</div><!--/highlight-wrapper -->

 
This will create a property with name owner and type Person. You can assign and read it just like you would any other property:

<div class="highlight-wrapper">

{% highlight swift %}
let jim = Person()
let rex = Dog()
rex.owner = jim
{% endhighlight%}

{% highlight objective-c %} 
Person *jim = [[Person alloc] init];
Dog    *rex = [[Dog alloc] init];
rex.owner = jim;
{% endhighlight %}

</div><!--/highlight-wrapper -->
 
When you do queries, children will not be fetched into memory at query time, but you will be able to navigate the links automatically without having to manually fetch children, _i.e._ doing calls such as
 `rex.owner.address.country` will automatically traverse the object graph for you to return the objects needed.
 
### Many-to-Many

You can establish a relationship to several objects from a single object via an RLMArray\<_Object_\> property declaration. RLMArrays are basically containers of RLMObjects, that behave very much like an NSArray, with the notable exception that they are typed.

To add a “dogs” property on our Person model, that links to multiple dogs, we must first define an `RLMArray<Dog>` type. This is done via a macro at the bottom of the corresponding model interface:
 
<div class="highlight-wrapper">

{% highlight swift %}
// Not needed in Swift
{% endhighlight%}

{% highlight objective-c %} 
//Dog.h
@interface Dog : RLMObject
... // property declarations
@end

RLM_ARRAY_TYPE(Dog) // Defines an RLMArray<Dog> type
{% endhighlight %}

</div><!--/highlight-wrapper -->

 
You can then declare properties of the `RLMArray<Dog>` type:

<div class="highlight-wrapper">

{% highlight swift %}
class Person: RLMObject {
    ... // other property declarations
    var dogs = RLMArray(objectClassName: Dog.className())
}
{% endhighlight%}

{% highlight objective-c %}  
// Person.h
@interface Person : RLMObject
... // other property declarations
@property RLMArray<Dog>   *dogs;
@end
{% endhighlight %}

</div><!--/highlight-wrapper -->

 
You can access & assign RLMArray properties as usual:

<div class="highlight-wrapper">

{% highlight swift %}
let someDogs = Dog.objectsWhere("name contains 'Fido'")
jim.dogs.addObjectsFromArray(someDogs)
jim.dogs.addObject(rex)
{% endhighlight%}

{% highlight objective-c %}  
// Jim is owner of Rex and all dogs named "Fido"
RLMArray *someDogs = [Dog objectsWhere:@"name contains 'Fido'"];
[jim.dogs addObjectsFromArray:someDogs];
[jim.dogs addObject:rex];
{% endhighlight %}

</div><!--/highlight-wrapper -->


**Note:** RLMArray properties on models are “copy on write”. Any direct assignment of that property will copy the references to the objects from the assignee into the assigned property.
In the example above, that means that any dogs added to `some_dogs` after `jim.dogs = some_dogs;` would _not_ also be added to `jim.dogs`.


## Notifications

The auto-updating Realm will send out notifications every time the underlying Realm is updated. These notifications can be observed by registering a block:

<div class="highlight-wrapper">

{% highlight swift %}
let token = realm.addNotificationBlock { note, realm in
    viewController.updateUI()
}
{% endhighlight%}

{% highlight objective-c %}
// Observe Realm Notifications

self.token = [realm addNotificationBlock:^(NSString *note, RLMRealm * realm) {
    [myViewController updateUI];
}];
{% endhighlight %}

</div><!--/highlight-wrapper -->

You can use the token to unsubscribe from the notification later on. We recommend you store this
token on your Main class, as losing reference to it will automatically unsubscribe you from the notification.

See [`[Realm addNotificationBlock:]`](api/Classes/RLMRealm.html#//api/name/addNotificationBlock:) and [`[Realm removeNotificationBlock:]`](api/Classes/RLMRealm.html#//api/name/removeNotificationBlock:) for details.

## Background Operations

Realm can be very efficient when writing large amounts of data by batching together multiple writes within a single transaction. Transactions can also be performed in the background using Grand Central Dispatch to avoid blocking the main thread. RLMRealm objects are not thread safe and cannot be shared across threads, so you must get an RLMRealm instance in each thread/dispatch_queue in which you want to read or write. Here's an example of inserting a million objects in a background queue:

<div class="highlight-wrapper">

{% highlight swift %}
dispatch_async(queue) {
    // Get realm and table instances for this thread
    let realm = RLMRealm.defaultRealm()

    // Break up the writing blocks into smaller portions
    // by starting a new transaction
    for idx1 in 0..<1000 {
		realm.beginWriteTransaction()

		// Add row via dictionary. Order is ignored.
		for idx2 in 0..<1000 {
	    	Person.createInDefaultRealmWithObject(
				["name": "\(idx1)", "birthdate": NSDate(timeIntervalSince1970: idx2)])
		}

		// Commit the write transaction
		// to make this data available to other threads
		realm.commitWriteTransaction()
    }
}
{% endhighlight%}

{% highlight objective-c %}
dispatch_async(queue, ^{    
    
    // Get realm and table instances for this thread
    RLMRealm *realm = [RLMRealm defaultRealm];
    
    // Break up the writing blocks into smaller portions
    // by starting a new transaction
    for (NSInteger idx1 = 0; idx1 < 1000; idx1++) {
        [realm beginWriteTransaction];
        
        // Add row via dictionary. Order is ignored.
        for (NSInteger idx2 = 0; idx2 < 1000; idx2++) {
            [Person createInRealm:realm
                       withObject:@{@"name"      : [self randomString],
                                    @"birthdate" : [self randomDate]}];
        }

        // Commit the write transaction
        // to make this data available to other threads
        [realm commitWriteTransaction];
    }
});
{% endhighlight %}

</div><!--/highlight-wrapper -->

See [RLMRealm](api/Classes/RLMRealm.html#) for more details.


## REST APIs

Due to Realm's small memory footprint and fast object querying, you can retrieve and persist as much as ten times the data you might normally fetch from a REST API, then query it directly from a Realm. This has several advantages:

- Retrieve large amounts of data with a single API call or by pre-fetching in the background, then persist it in the Realm.
- Since Realm is thread-safe, you can easily asynchronize this task and update your views once the REST call has completed.
- Query data directly from the Realm, rather than waiting for the API to process complex queries server side.
- Offer a strong user experience while offline since you can cache large datasets that you can still query & update.
- Reduce server-side load: while the first few interactions may generate more traffic than usual, having a cache dataset can help reduce server-side load over time by reducing the frequency at which have to fetch the same data over & over.

### Best Practices

1. **Asynchronous Requests** — Since Realm can hold a large amount of data in a small footprint, a good practice is to execute multiple API requests in the background to build a larger local data set. This creates a more seamless user experience in your app, as the user never experiences wait time for an API request to return on the main thread. You can use [Notifications](#notifications) to monitor the progress of your REST requests.
2. **Caching datasets larger than what will be immediately displayed to the user** — We recommend you pre-fetch data as often as possible and store it locally in your Realms. For example, if you are only displaying 10 results per page in a List View, fetch the next 3-4 pages of results if the user is likely to visit them. You should consider doing the same with map view (fetch results for the surrounding areas) or for your app in general (pre-fetch data for screens the user is likely to browse to during the normal course of his usage).
3. **Insert-or-update** — If your dataset has a unique identifier such as a primary key (or set of unicity conditions), you can use it to easily code insert-or-update logic: when receiving a response from the API, you can check if each record already exists by querying the Realm for it. If it does exist locally, update with the latest details from the response, if not, insert it into the Realm.


### Example
The following is a simple example of how you can use Realm with a REST API. In this example, we'll retrieve a JSON-formatted data set from the foursquare API, then save it as Realm Objects in the default Realm.

For a real-time example of a similar use case in action, check out our [video demo](http://static.realm.io/videos/demo.mp4).

First we create an instance of the default Realm to persist the data to, and fetch our data set from the API. For simplicity in this example we use `[NSData initWithContentsOfURL]`.

<div class="highlight-wrapper">

{% highlight swift %}
// Call the API
let url = NSURL(string: "https://api.foursquare.com/v2/venues/search?near=San%20Francisco&limit=50")
let response = NSData(contentsOfURL: url)

// De-serialize the response to JSON
let json = NSJSONSerialization.JSONObjectWithData(response,
    options: NSJSONReadingOptions(0),
    error: nil)["response"]
{% endhighlight%}

{% highlight objective-c %}
RLMRealm *realm = [RLMRealm defaultRealm];

// Call the API
NSData *response = [ [NSData alloc] initWithContentsOfURL:
                     [NSURL URLWithString:@"https://api.foursquare.com/v2/venues/search?near=San%20Francisco&limit=50"]];

// Deserialize the response to JSON
NSDictionary *json = [[ NSJSONSerialization
                        JSONObjectWithData:response
                        options:kNilOptions
                        error:&error ] objectForKey:@"response"];
{% endhighlight %}

</div><!--/highlight-wrapper -->

The response contains a JSON array of venues similar to this:

{% highlight json %}
{
  "venues": [
    {
      "id": "4c82f252d92ea09323185072",
      "name": "Golden Gate Park",
      "contact": {
        "phone": "4152522590"
      },
      "location": {
        "lat": 37.773835608329,
        "lng": -122.41962432861,
        "postalCode": "94103",
        "cc": "US",
        "state": "California",
        "country": "United States"          
      }
    }
  ]
}
{% endhighlight %}

There are several ways we may want to import this JSON into our Realm. You could read the NSDictionary and map the properties to a single RLMObject manually via a custom insert function. For the sake of this example, we will instead directly insert the NSDictionary in the Realm and have it automatically be mapped to a hierarchy of RLMObjects that will be created on the fly for us. For this to work, we need an RLMObject structure whose properties will match all the keys in the JSON exactly. JSON keys not matched by an RLMObject property will be ignored on insert. The following RLMObject declarations would work:

<div class="highlight-wrapper">

{% highlight swift %}
class Contact: RLMObject {
    var phone = ""
}

class Location: RLMObject {
    var lat = 0.0  // latitude
    var lng = 0.0  // longitude
    var postalCode = ""
    var cc = ""
    var state = ""
    var country = ""
}

class Venue: RLMObject {
    var id = ""
    var name = ""
    var contact = Contact()
    var location = Location()
}
{% endhighlight%}

{% highlight objective-c %}
// Venue.h
@interface Venue : RLMObject
@property NSString *id;
@property NSString *name;
@property Contact  *contact;
@property Location *location;
@end
RLM_ARRAY_TYPE(Venue)

// Contact.h
@interface Contact : RLMObject
@property NSString *phone;
@end
RLM_ARRAY_TYPE(Contact)

// Location.h
@interface Location : RLMObject
@property double lat; // latitude
@property double lng; // longitude
@property NSString *postalCode;
@property NSString *cc;
@property NSString *state;
@property NSString *country;
@end
RLM_ARRAY_TYPE(Location)
{% endhighlight %}

</div><!--/highlight-wrapper -->

Since the result set is given to us as an array we can simply add it straight to the default Realm by calling `[RLMRealm addObjectsFromArray:]`. This will convert any array of key-value compliant objects to RLMObjects and save them to the default Realm:

<div class="highlight-wrapper">

{% highlight swift %}
//Extract the array of venues from the response
let venues = json["venues"] as [NSDictionary]

realm.beginWriteTransaction()
// Save one Venue object (& dependents) for each element of the array
for venue in venues {
    Venue.createInDefaultRealmWithObject(venue)
}
realm.commitWriteTransaction()
{% endhighlight%}

{% highlight objective-c %}
//Extract the array of venues from the response
NSArray *venues = json[@"venues"];

[realm beginWriteTransaction];
// Save one Venue object (& dependents) for each element of the array
for (NSDictionary *venue in venues) {
    [Venue createInDefaultRealmWithObject:venue];
}
[realm commitWriteTransaction];
{% endhighlight %}

</div><!--/highlight-wrapper -->

## Migrations

When working with any database, it is likely your data model will change over time. Since data models in Realm are defined as standard Objects, changing them is as easy as changing the interface of the corresponding RLMObject subclass. For example, suppose we have the following interface in 'Person.h':

<div class="highlight-wrapper">

{% highlight swift %}
class Person: RLMObject {
    var firstName = ""
    var firstName = ""
    var age = 0
}
{% endhighlight%}

{% highlight objective-c %}
@interface Person : RLMObject
@property NSString *firstName;
@property NSString *lastName;
@property int age;
@end
{% endhighlight %}
</div><!--/highlight-wrapper -->

Next, we want to update the data model to require a 'fullName' property, rather than separate first and last names. To do this, we simply change the subclass interface to the following:

<div class="highlight-wrapper">

{% highlight swift %}
class Person: RLMObject {
    var fullName = ""
    var age = 0
}
{% endhighlight%}

{% highlight objective-c %}
@interface Person : RLMObject
@property NSString *fullName;
@property int age;
@end
{% endhighlight %}
</div><!--/highlight-wrapper -->

Just changing your code to the new definition will work fine, if you have no data stored on disk under the old schema. But if you do, there will be a mismatch between what Realm sees defined in code, and the data Realm sees on disk. In short if you change your schema definition in one of your models and then instantiate a realm with [`[RLMRealm defaultRealm]`](api/Classes/RLMRealm.html#//api/name/defaultRealm) (or a similar realm instantiation call), that call will throw an NSException with a message that you should run a migration.

Realms that contain at least one class that has been redefined must be migrated to the current schema before they can be accessed. To make this process easy, Realm provides specialized classes and methods for handling schema migration.

Migrating a Realm to a new schema takes just two steps, and must be done before anything else so we recommend you complete them from inside your `[AppDelegate didFinishLaunchingWithOptions:]`:

### Performing a Migration

You define a migration by implementing an `RLMMigrationBlock` which you pass into a call to [`[RLMRealm migrateDefaultRealmWithBlock:]`](api/Classes/RLMRealm.html#//api/name/migrateDefaultRealmWithBlock:) for the default Realm or [`[RLMRealm migrateRealmAtPath:withBlock:]`](api/Classes/RLMRealm.html#//api/name/migrateRealmAtPath:withBlock:) for other Realm instances. Your migration block provides all the logic for converting data models from previous schemas to the new schema. 

For example, suppose we want to migrate the 'Person' subclass from above. To do this, the minimal necessary migration block would look like the following:

<div class="highlight-wrapper">

{% highlight swift %}

{% endhighlight%}

{% highlight objective-c %}
// Inside your [AppDelegate didFinishLaunchingWithOptions:]

RLMMigrationBlock migrationBlock = ^NSUInteger(RLMMigration *migration,
                                                 NSUInteger oldSchemaVersion) {
  // We haven’t migrated anything yet, so oldSchemaVersion == 0
  if (oldSchemaVersion < 1) { 
    // Nothing to do!
    // Realm will automatically detect new properties & removed properties
    // And will update the schema on disk automatically
  }
  // Return the latest version number (always set manually)
  // Must be a higher than the previous version or an RLMException is thrown
  return 1;
};

// Apply the migration block above to the default Realm
[RLMRealm migrateDefaultRealmWithBlock:migrationBlock];
{% endhighlight %}
</div><!--/highlight-wrapper -->

At the very minimum, all we need to do is `return 1;` to indicate the that the schema has been upgraded (automatically) by Realm.  
_N.B._ The version number returned can be either an integer (version) or timestamp (epoch). We recommend you set it manually in the code as it defines the current version of the schema your app is using.  
While you must manually return the version number to the app at the end of your migration block, note that Realm takes care of updating the schema version number inside the realm on disk.

While this is the minimal acceptable migration, we probably want to use this block to pre-fill the “fullName” property with something more meaningful. Within the migration block we can call [`[RLMMigration enumerateObjects:block:]`](api/Classes/RLMMigration.html#//api/name/enumerateObjects:block:) to enumerate each Realm Object of a certain type, and apply any necessary migration logic. Notice how for each enumeration the existing RLMObject instance is accessed via an `oldObject` variable, and the updated instance is accessed via `newObject`:

<div class="highlight-wrapper">

{% highlight swift %}

{% endhighlight%}

{% highlight objective-c %}
// Inside your [AppDelegate didFinishLaunchingWithOptions:]

// Perform a migration defining the migration block inline
[RLMRealm migrateDefaultRealmWithBlock:^NSUInteger(RLMMigration *migration, NSUInteger oldSchemaVersion) {
  // We haven’t migrated anything yet, so oldSchemaVersion == 0
  if (oldSchemaVersion < 1) { 
    // The enumerateObjects:block: method iterates
    // over every 'Person' object stored in the Realm file
    [migration enumerateObjects:Person.className
                          block:^(RLMObject *oldObject, RLMObject *newObject) {    
      
      // Update each individual 'Person' object on disk using this logic:
      newObject[@"fullName"] = [NSString stringWithFormat:@"%@ %@",
                                         oldObject[@"firstName"],
                                         oldObject[@"lastName"]];          
    }];
  }
  // Return the latest version number (always set manually)
  // Must be a higher than the previous version or an RLMException is thrown
  return 1;
}];
{% endhighlight %}
</div><!--/highlight-wrapper -->

Once the migration is successfully completed, the Realm and all of its Objects can be accessed as usual by your app.

### Adding more versions

Suppose now we change the data model for the 'Person' subclass yet again, for a total of three different schemas:

<div class="highlight-wrapper">

{% highlight swift %}
// v0
class Person: RLMObject {
    var firstName = ""
    var firstName = ""
    var age = 0
}

// v1
class Person: RLMObject {
    var fullName = "" // new property
    var age = 0
}

// v2
class Person: RLMObject {
    var fullName = ""
    var email = "" // new property
    var age = 0
}

{% endhighlight%}

{% highlight objective-c %}
// v0
@interface Person : RLMObject
@property NSString *firstName;
@property NSString *lastName;
@property int age;
@end

// v1
@interface Person : RLMObject
@property NSString *fullName; // new property
@property int age;
@end

// v2
@interface Person : RLMObject
@property NSString *fullName;
@property NSString *email;   // new property
@property int age;
@end
{% endhighlight %}
</div><!--/highlight-wrapper -->

The logic in our migration block might look like the following. 

<div class="highlight-wrapper">

{% highlight swift %}

{% endhighlight%}

{% highlight objective-c %}
[RLMRealm migrateDefaultRealmWithBlock:^NSUInteger(RLMMigration *migration, NSUInteger oldSchemaVersion) {
    // We haven’t migrated anything yet, so oldSchemaVersion == 0
    if (oldSchemaVersion < 1) {
        // The enumerateObjects:block: method iterates
        // over every 'Person' object stored in the Realm file
        [migration enumerateObjects:Person.className block:^(RLMObject *oldObject, RLMObject *newObject) {

            // Add the 'fullName' property only to Realms with a schema version of 0
            if (oldSchemaVersion < 1) {
                newObject[@"fullName"] = [NSString stringWithFormat:@"%@ %@",
                                          oldObject[@"firstName"],
                                          oldObject[@"lastName"]];
            }

            // Add the 'email' property to Realms with a schema version of 0 or 1
            if (oldSchemaVersion < 2) {
                newObject[@"email"] = [[NSString alloc] init];
            }
        }];            }
    // Return the latest version number (always set manually)
    // Must be a higher than the previous version or an RLMException is thrown
    return 2;
}];

{% endhighlight %}
</div><!--/highlight-wrapper -->

For a more complete look at the implementation of a data schema migration, check out our [migration sample app](https://github.com/realm/realm-cocoa/tree/master/examples/objc/RealmMigrationExample).

### Linear Migrations

Suppose we have two users for our app: JP and Tim. JP updates the app very often, but Tim happens to skip a few versions between sessions in. It’s likely that JP has seen every new version of our app, and every schema upgrade in sequence: he downloaded a version of the app that took him from v0 to v1, another update that took him from v1 to v2. In contrast, it’s possible that Tim will download an update of the app that would need to take him from v0 to v2 immediately. Structuring your migration blocks with **_non-nested_** `if (oldSchemaVersion < X)` calls ensures that they will see all necessary upgrades, no matter which schema version they start from.

Another scenario may arise in the case of users who skipped versions of your app. If you delete a property “say address” at version 2 and re-introduce it at version 3, and a user jumps from version 1 to version 3, Realm will not be able to automatically detect the deletion of the “address” property, as there will be no mismatch between the schema on disk and the schema in the code for that property. This will lead to Tim’s Person object having a v3 address property that has the contents of the v1 address property. This may not be a problem, unless you changed the internal storage representation of that property between v1 and v3 (say, went from an ISO address representation to a custom one). To avoid this, we recommend you nil out or the address property on the `if (oldSchemaVersion < 3)` statement, guaranteeing that all realms upgraded to version 3 will have a correct dataset.



## Next Steps

You can download a [simple example](http://static.realm.io/downloads/ios/RealmSimpleExample.zip) to see Realm used in practice in an app. (We’re getting more samples ready!)

Happy hacking! You can always talk to a live human developer at [help@realm.io](mailto:help@realm.io).
</div><!--/docs-wrapper -->
</div><!--/col-->


<div class="col-md-3 col-md-offset-1">
<div class="navbar-docs visible-md visible-lg" data-spy="affix" data-offset-top="325">
* toc
{:toc .nav .nav-pills .nav-stacked}
</div>
</div>
